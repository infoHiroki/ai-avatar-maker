# モジュール詳細設計書

**プロジェクト名**: ブログ記事→YouTube動画自動生成システム
**バージョン**: 1.0.0
**作成日**: 2025年11月15日

---

## 📋 目次

1. [コーディング規約](#コーディング規約)
2. [モジュール一覧](#モジュール一覧)
3. [chatgpt モジュール](#chatgptモジュール)
4. [cartesia モジュール](#cartesiaモジュール)
5. [did モジュール](#didモジュール)
6. [youtube モジュール](#youtubeモジュール)
7. [utils モジュール](#utilsモジュール)
8. [エラーハンドリング](#エラーハンドリング)

---

## コーディング規約

### 基本方針

```yaml
原則:
  - KISS: シンプルに書く
  - YAGNI: 必要な機能のみ
  - DRY: 重複を避ける
  - Go言語スタイル: 明示的で読みやすく
```

### 型ヒント（必須）

```python
# ✅ OK: すべての関数に型ヒント
from typing import Optional, Dict, List, Tuple

def generate_audio(
    text: str,
    voice_id: str,
    speed: float = 1.0
) -> Tuple[Optional[str], Optional[Exception]]:
    """音声生成"""
    pass

# ❌ NG: 型ヒントなし
def generate_audio(text, voice_id, speed=1.0):
    pass
```

### Docstring（必須・Google Style）

```python
def generate_script(blog_url: str, max_words: int = 150) -> Tuple[Optional[str], Optional[Exception]]:
    """
    ブログ記事からYouTubeスクリプトを生成

    Args:
        blog_url: ブログ記事のURL
        max_words: 生成するスクリプトの最大単語数

    Returns:
        (script, error):
            - 成功時: (生成されたスクリプト, None)
            - 失敗時: (None, エラーオブジェクト)

    Example:
        >>> script, err = generate_script("https://blog.example.com/post1")
        >>> if err:
        >>>     print(f"エラー: {err}")
        >>> else:
        >>>     print(script)

    Raises:
        この関数はRaiseしない（エラーはtuple返却）
    """
    pass
```

### エラーハンドリング（Go言語スタイル）

```python
# ✅ OK: tuple返却パターン
def api_call(url: str) -> Tuple[Optional[Dict], Optional[Exception]]:
    """
    API呼び出し

    Returns:
        (result, error): 成功時は (result, None)、失敗時は (None, error)
    """
    try:
        response = requests.get(url)
        response.raise_for_status()
        return (response.json(), None)
    except Exception as e:
        return (None, e)

# 使用側
result, err = api_call("https://api.example.com")
if err:
    logger.error(f"API呼び出し失敗: {err}")
    return
# 正常処理
process(result)


# ❌ NG: エラーを隠蔽
def api_call(url: str) -> Dict:
    try:
        return requests.get(url).json()
    except:
        return {}  # エラーが不明瞭
```

### 関数サイズ

```python
# ✅ OK: 小さな関数（20行以内目安）
def validate_blog_url(url: str) -> bool:
    """URLバリデーション"""
    if not url:
        return False
    if not url.startswith("http"):
        return False
    return True

def fetch_blog_content(url: str) -> Tuple[Optional[str], Optional[Exception]]:
    """ブログ記事取得"""
    if not validate_blog_url(url):
        return (None, ValueError("無効なURL"))

    try:
        response = requests.get(url, timeout=30)
        response.raise_for_status()
        return (response.text, None)
    except Exception as e:
        return (None, e)


# ❌ NG: 大きな関数
def generate_video_from_blog(url):
    # 100行のロジック...
    pass
```

### 定数定義

```python
# ✅ OK: 定数を定義
MAX_SCRIPT_WORDS = 150
API_TIMEOUT_SECONDS = 30
RETRY_COUNT = 3

if len(words) > MAX_SCRIPT_WORDS:
    words = words[:MAX_SCRIPT_WORDS]


# ❌ NG: マジックナンバー
if len(words) > 150:
    words = words[:150]
```

### インポート順序（PEP8）

```python
# 1. 標準ライブラリ
import os
import sys
from typing import Optional, Dict, List, Tuple

# 2. サードパーティ
import requests
import streamlit as st
from pydantic import BaseModel

# 3. ローカルモジュール
from modules import chatgpt, cartesia
from utils.config import load_config
from utils.logger import get_logger
```

### クラス vs 関数

```python
# ✅ OK: 状態を持つ場合はクラス
class CartesiaClient:
    """Cartesia API クライアント"""

    def __init__(self, api_key: str, voice_id: str):
        self.api_key = api_key
        self.voice_id = voice_id
        self.ws = None

    def connect(self) -> Tuple[bool, Optional[Exception]]:
        """WebSocket接続"""
        pass

    def generate(self, text: str) -> Tuple[Optional[str], Optional[Exception]]:
        """音声生成"""
        pass


# ✅ OK: 状態を持たない場合は関数
def validate_script_length(text: str, max_words: int) -> bool:
    """スクリプト長バリデーション"""
    words = text.split()
    return len(words) <= max_words
```

---

## モジュール一覧

| モジュール | 責務 | 依存 |
|-----------|------|------|
| `modules/chatgpt.py` | スクリプト生成 | OpenAI API |
| `modules/cartesia.py` | 音声生成 | Cartesia API, Cloudinary |
| `modules/did.py` | 動画生成 | D-ID API |
| `modules/youtube.py` | YouTube投稿 | YouTube Data API |
| `utils/config.py` | 設定管理 | なし |
| `utils/logger.py` | ロギング | なし |
| `utils/errors.py` | エラー定義 | なし |

---

## chatgptモジュール

### 概要

```python
"""
modules/chatgpt.py

ブログ記事からYouTubeスクリプトを生成

機能:
  - ブログ記事の取得
  - ChatGPT APIでスクリプト生成
  - 文字数制御
  - エラーハンドリング

依存:
  - OpenAI API (gpt-4o-mini推奨)
  - requests
"""
```

### 関数仕様

#### `generate_script()`

```python
def generate_script(
    blog_url: str,
    max_words: int = 150,
    api_key: Optional[str] = None
) -> Tuple[Optional[str], Optional[Exception]]:
    """
    ブログ記事からYouTubeスクリプトを生成

    Args:
        blog_url: ブログ記事のURL
        max_words: 最大単語数（デフォルト: 150）
        api_key: OpenAI APIキー（Noneの場合は環境変数から取得）

    Returns:
        (script, error):
            - 成功: (生成されたスクリプト, None)
            - 失敗: (None, エラー)

    Example:
        >>> script, err = generate_script(
        ...     "https://blog.example.com/post1",
        ...     max_words=150
        ... )
        >>> if err:
        ...     print(f"エラー: {err}")

    Notes:
        - タイムアウト: 30秒
        - リトライ: 3回（指数バックオフ）
        - エラーログを出力
    """
    pass
```

#### `fetch_blog_content()`

```python
def fetch_blog_content(url: str) -> Tuple[Optional[str], Optional[Exception]]:
    """
    ブログ記事の本文を取得

    Args:
        url: ブログ記事URL

    Returns:
        (content, error): 記事本文またはエラー

    Notes:
        - タイムアウト: 30秒
        - HTMLからテキスト抽出（BeautifulSoup使用）
    """
    pass
```

#### `call_chatgpt_api()`

```python
def call_chatgpt_api(
    prompt: str,
    api_key: str,
    model: str = "gpt-4o-mini"
) -> Tuple[Optional[str], Optional[Exception]]:
    """
    ChatGPT APIを呼び出し

    Args:
        prompt: プロンプト
        api_key: OpenAI APIキー
        model: 使用モデル

    Returns:
        (response, error): ChatGPTの応答またはエラー
    """
    pass
```

### プロンプトテンプレート

```python
SCRIPT_GENERATION_PROMPT = """
以下のブログ記事を、YouTube Shorts（60秒）用のスクリプトに変換してください。

要件:
- 150単語以内
- 自然な日本語
- 視聴者に語りかける口調
- 「今日は〜について解説します」で始める
- 「それでは、また次回！」で終える

ブログ記事:
{blog_content}

スクリプト:
"""
```

### エラー定義

```python
class ChatGPTError(Exception):
    """ChatGPT関連のエラー"""
    pass

class BlogFetchError(Exception):
    """ブログ記事取得エラー"""
    pass
```

---

## cartesiaモジュール

### 概要

```python
"""
modules/cartesia.py

Cartesia APIで音声生成

機能:
  - WebSocket接続管理
  - 音声生成（声クローン使用）
  - Cloudinaryアップロード
  - エラーハンドリング

依存:
  - Cartesia API
  - Cloudinary API
  - websockets
"""
```

### クラス設計

#### `CartesiaClient`

```python
class CartesiaClient:
    """
    Cartesia API クライアント

    Attributes:
        api_key: Cartesia APIキー
        voice_id: 声クローンID
        ws: WebSocket接続
        cloudinary_config: Cloudinary設定

    Example:
        >>> client = CartesiaClient(
        ...     api_key="cart_xxx",
        ...     voice_id="voice_123"
        ... )
        >>> audio_url, err = client.generate("こんにちは")
        >>> if err:
        ...     print(f"エラー: {err}")
    """

    def __init__(
        self,
        api_key: str,
        voice_id: str,
        cloudinary_config: Optional[Dict] = None
    ):
        """初期化"""
        pass

    def generate(
        self,
        text: str,
        speed: float = 1.0
    ) -> Tuple[Optional[str], Optional[Exception]]:
        """
        音声生成

        Args:
            text: 生成するテキスト
            speed: 再生速度（0.5-2.0）

        Returns:
            (audio_url, error): CloudinaryのURLまたはエラー

        Process:
            1. WebSocket接続
            2. 音声生成リクエスト
            3. ストリーミング受信
            4. MP3ファイル保存
            5. Cloudinaryアップロード
            6. URL返却
        """
        pass

    def _connect(self) -> Tuple[bool, Optional[Exception]]:
        """WebSocket接続"""
        pass

    def _upload_to_cloudinary(
        self,
        audio_file_path: str
    ) -> Tuple[Optional[str], Optional[Exception]]:
        """Cloudinaryにアップロード"""
        pass

    def close(self) -> None:
        """接続を閉じる"""
        pass
```

### 定数

```python
CARTESIA_WS_URL = "wss://api.cartesia.ai/v1/audio/stream"
DEFAULT_SPEED = 1.0
MIN_SPEED = 0.5
MAX_SPEED = 2.0
AUDIO_FORMAT = "mp3"
SAMPLE_RATE = 44100
```

---

## didモジュール

### 概要

```python
"""
modules/did.py

D-ID APIでリップシンク動画生成

機能:
  - 動画生成リクエスト
  - ポーリング（完了待機）
  - 動画URL取得
  - エラーハンドリング

依存:
  - D-ID API
  - requests
"""
```

### クラス設計

#### `DIDClient`

```python
class DIDClient:
    """
    D-ID API クライアント

    Attributes:
        api_key: D-ID APIキー
        base_url: APIベースURL

    Example:
        >>> client = DIDClient(api_key="did_xxx")
        >>> video_url, err = client.generate(
        ...     audio_url="https://...",
        ...     avatar_url="https://..."
        ... )
    """

    def __init__(self, api_key: str):
        """初期化"""
        self.api_key = api_key
        self.base_url = "https://api.d-id.com"

    def generate(
        self,
        audio_url: str,
        avatar_url: str
    ) -> Tuple[Optional[str], Optional[Exception]]:
        """
        リップシンク動画を生成

        Args:
            audio_url: 音声ファイルURL
            avatar_url: アバター画像URL

        Returns:
            (video_url, error): 動画URLまたはエラー

        Process:
            1. 動画生成リクエスト（POST /talks）
            2. talk_id取得
            3. ポーリング（GET /talks/{id}）
            4. status=done まで待機（最大5分）
            5. 動画URL返却
        """
        pass

    def _create_talk(
        self,
        audio_url: str,
        avatar_url: str
    ) -> Tuple[Optional[str], Optional[Exception]]:
        """動画生成リクエスト"""
        pass

    def _poll_status(
        self,
        talk_id: str,
        timeout_seconds: int = 300
    ) -> Tuple[Optional[str], Optional[Exception]]:
        """
        ステータスポーリング

        Args:
            talk_id: Talk ID
            timeout_seconds: タイムアウト（秒）

        Returns:
            (video_url, error): 動画URLまたはエラー

        Notes:
            - ポーリング間隔: 5秒
            - タイムアウト: 5分
        """
        pass
```

### 定数

```python
DID_API_BASE_URL = "https://api.d-id.com"
POLL_INTERVAL_SECONDS = 5
POLL_TIMEOUT_SECONDS = 300
STATUS_DONE = "done"
STATUS_ERROR = "error"
STATUS_PROCESSING = "created"
```

---

## youtubeモジュール

### 概要

```python
"""
modules/youtube.py

YouTube Data APIで動画投稿

機能:
  - 動画ダウンロード
  - YouTube投稿（下書き）
  - メタデータ設定
  - エラーハンドリング

依存:
  - YouTube Data API
  - google-api-python-client
"""
```

### 関数仕様

#### `upload_video()`

```python
def upload_video(
    video_url: str,
    title: str,
    description: str,
    credentials_path: str
) -> Tuple[Optional[str], Optional[Exception]]:
    """
    YouTubeに動画を投稿（下書き）

    Args:
        video_url: 動画URL
        title: 動画タイトル
        description: 説明文
        credentials_path: OAuth認証情報ファイルパス

    Returns:
        (youtube_url, error): YouTube URLまたはエラー

    Process:
        1. 動画ダウンロード
        2. OAuth認証
        3. YouTube APIで投稿（privacyStatus=private）
        4. YouTube URL返却

    Example:
        >>> url, err = upload_video(
        ...     video_url="https://...",
        ...     title="テスト動画",
        ...     description="説明",
        ...     credentials_path="credentials.json"
        ... )
    """
    pass
```

#### `download_video()`

```python
def download_video(
    video_url: str,
    output_path: str
) -> Tuple[bool, Optional[Exception]]:
    """
    動画をダウンロード

    Args:
        video_url: 動画URL
        output_path: 保存先パス

    Returns:
        (success, error): 成功フラグまたはエラー
    """
    pass
```

---

## utilsモジュール

### utils/config.py

```python
"""
設定ファイル管理

機能:
  - config.yaml読み込み
  - 環境変数からの設定読み込み
  - バリデーション
"""

def load_config(config_path: str = "config.yaml") -> Dict:
    """
    設定ファイルを読み込み

    Args:
        config_path: 設定ファイルパス

    Returns:
        設定辞書

    Raises:
        FileNotFoundError: ファイルが存在しない
        yaml.YAMLError: YAML parse エラー
    """
    pass
```

### utils/logger.py

```python
"""
ロギング設定

機能:
  - ロガー設定
  - ファイル・コンソール出力
  - ログレベル制御
"""

def get_logger(name: str) -> logging.Logger:
    """
    ロガーを取得

    Args:
        name: ロガー名（通常は__name__）

    Returns:
        Loggerインスタンス

    Example:
        >>> logger = get_logger(__name__)
        >>> logger.info("処理開始")
    """
    pass
```

### utils/errors.py

```python
"""
カスタムエラー定義
"""

class VideoGenerationError(Exception):
    """動画生成エラーの基底クラス"""
    pass

class ScriptGenerationError(VideoGenerationError):
    """スクリプト生成エラー"""
    pass

class AudioGenerationError(VideoGenerationError):
    """音声生成エラー"""
    pass

class VideoCreationError(VideoGenerationError):
    """動画作成エラー"""
    pass

class YouTubeUploadError(VideoGenerationError):
    """YouTube投稿エラー"""
    pass
```

---

## エラーハンドリング

### 基本パターン

```python
# パターン1: tuple返却（推奨）
def some_operation() -> Tuple[Optional[T], Optional[Exception]]:
    try:
        result = do_something()
        return (result, None)
    except Exception as e:
        logger.error(f"エラー: {e}")
        return (None, e)

# 使用側
result, err = some_operation()
if err:
    # エラーハンドリング
    st.error(f"処理に失敗しました: {err}")
    return
# 正常処理
process(result)
```

### リトライパターン

```python
def retry_on_error(
    func: Callable,
    max_retries: int = 3,
    backoff_factor: float = 2.0
) -> Tuple[Optional[Any], Optional[Exception]]:
    """
    エラー時にリトライ

    Args:
        func: 実行する関数
        max_retries: 最大リトライ回数
        backoff_factor: バックオフ係数

    Returns:
        (result, error): 結果またはエラー
    """
    for attempt in range(max_retries):
        result, err = func()
        if err is None:
            return (result, None)

        if attempt < max_retries - 1:
            wait_time = backoff_factor ** attempt
            logger.warning(f"リトライ {attempt + 1}/{max_retries}: {wait_time}秒待機")
            time.sleep(wait_time)

    return (None, Exception(f"{max_retries}回リトライしましたが失敗"))
```

### Streamlitでのエラー表示

```python
# ユーザーフレンドリーなエラー表示
def handle_error(error: Exception, context: str) -> None:
    """
    エラーを適切に表示

    Args:
        error: エラーオブジェクト
        context: エラーコンテキスト
    """
    # ログ出力（開発者向け）
    logger.error(f"{context}でエラー: {error}", exc_info=True)

    # ユーザー向けメッセージ
    st.error(f"""
    ### ⚠️ エラーが発生しました

    **処理**: {context}

    **エラー**: {str(error)}

    **対処方法**:
    1. 入力内容を確認してください
    2. しばらく待ってから再試行してください
    3. 問題が続く場合は管理者に連絡してください
    """)
```

---

**最終更新**: 2025年11月15日
**次回レビュー**: 実装開始時
